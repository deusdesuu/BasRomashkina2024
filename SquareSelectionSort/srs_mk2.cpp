// Мячин Валентин БАС2
#include <iostream>
#include <locale>
#include <cmath>


void print(int* mas, int n) {
    for (int i = 0; i < n; ++i) {
        std::cout << mas[i] << ' ';
    }
    std::cout << std::endl;
}
void print_ptr(int** mas, int n) {
    for (int i = 0; i < n; ++i) {
        std::cout << *mas[i] << ' ';
    }
    std::cout << std::endl;
}
void fill_worst(int* mas, int n) {
    for (int i = 0; i < n; ++i) {
        mas[i] = n - i;
    }
}
void fill_best(int* mas, int n) {
    for (int i = 0; i < n; ++i) {
        mas[i] = i + 1;
    }
}
void fill_avg(int* mas, int n) {
    std::srand(std::time(nullptr));
    for (int i = 0; i < n; ++i) {
        mas[i] = rand() % 19 - 9;
    }
}
void SquareSelectionSort(int* A, int n) {
    int m = 0, c = 0;
    int sqrtN = sqrt(n);

    bool tail = 0;
    if (n % sqrtN > 0) { 
        ++sqrtN;
        tail = 1;
    }
    // Находим максимум, который
    // Будем использовать как фиктивный элемент
    int max = A[0]; ++m;
    for (int i = 1; i < n; ++i) {
        ++c;
        if (A[i] > max) {
            max = A[i];
            ++m;
        }
    }
    // Инициализируем и заполняем массив В
    // В В будем хранить указатели на ячейки памяти
    // В которых располагаются элементы А
    // Чтобы в дальнейшем сэкономить время
    // На изменении элементов А
    int Bn = n / sqrtN + tail; // длина В
    int** B = new int*[Bn];
    int Bi = 0; // индекс по которому будем добавлять элементы в В
    int* min = &(A[0]); ++m;
    for (int i = 1; i < n; ++i) {
        ++c;
        if (A[i] < *min) {
            min = &(A[i]);
            ++m;
        }
        // Если прошли Bi'ую группу
        // То добавляем минимум в В
        if ((i + 1) % sqrtN == 0) {
            B[Bi++] = min; ++m;
            min = &A[++i]; ++m;
        }
    }
    if (tail) {
        B[Bi] = min; ++m;
    }
    // Основная часть сортировки
    int* C = new int[n];
    int mini; // Номер группы / индекс В
    /*
    print(A, n);
    print_ptr(B, Bn);
    print(C, n);
    std::cout << "-------------------------------------------\n";
    */
    for (int j = 0; j < n; ++j) {
        // Находим минимальный элемент в В
        min = B[0]; ++m;
        mini = 0;
        for (int i = 1; i < Bn; ++i) {
            ++c;
            if (*B[i] < *min) {
                min = B[i]; ++m;
                mini = i;
            }
        }
        // Добавляем минимальный элемент в С
        C[j] = *min; ++m;
        /*
            Находим новый минимальный элемент
            Внутри группы
        */
        // Старому минимуму присваиваем значение максимума
        // Т.к. ptr то значение сразу меняется и в В и в А
        *min = max; ++m;
        min = &(A[mini * sqrtN]); ++m;
        for (int i = mini * sqrtN + 1; (i < (mini + 1) * sqrtN) && (i < n); ++i) {
            ++c;
            if (A[i] < *min) {
                min = &A[i]; ++m;
            }
        }
        B[mini] = min;
        /*
        print(A, n);
        print_ptr(B, Bn);
        print(C, n);
        std::cout << "-------------------------------------------\n";
        */
    }
    // Копируем элементы из С обратно в А
    for (int i = 0; i < n; ++i) {
        A[i] = C[i]; ++m;
    }
    std::cout << "Количество сравнений: " << c << std::endl;
    std::cout << "Количество перемещений: " << m << std::endl;
    delete[] B;
    delete[] C;
}
int main() {
    setlocale(LC_ALL, "rus");
    int n; std::cout << "n  = "; std::cin >> n;
    int* mas = new int[n];

    fill_best(mas, n);
    std::cout << "\nИсходный массив в лучшем случае:\n\t"; print(mas, n);
    SquareSelectionSort(mas, n);
    std::cout << "Результат работы сортировки:\n\t"; print(mas, n);

    std::cout << "\n-----------------------------------------------\n";

    fill_worst(mas, n);
    std::cout << "\nИсходный массив в худшем случае:\n\t"; print(mas, n);
    SquareSelectionSort(mas, n);
    std::cout << "Результат работы сортировки:\n\t"; print(mas, n);

    std::cout << "\n-----------------------------------------------\n";

    fill_avg(mas, n);
    std::cout << "\nИсходный массив в среднем случае:\n\t"; print(mas, n);
    SquareSelectionSort(mas, n);
    std::cout << "Результат работы сортировки:\n\t"; print(mas, n);

    delete[] mas;
    return 0;
}
/*
Test (только худший случай):

n  = 10

Исходный массив в худшем случае:
        10 9 8 7 6 5 4 3 2 1
10 9 8 7 6 5 4 3 2 1
7 3 1
-842150451 -842150451 -842150451 -842150451 -842150451 -842150451 -842150451 -842150451 -842150451 -842150451
-------------------------------------------
10 9 8 7 6 5 4 3 2 10
7 3 2
1 -842150451 -842150451 -842150451 -842150451 -842150451 -842150451 -842150451 -842150451 -842150451
-------------------------------------------
10 9 8 7 6 5 4 3 10 10
7 3 10
1 2 -842150451 -842150451 -842150451 -842150451 -842150451 -842150451 -842150451 -842150451
-------------------------------------------
10 9 8 7 6 5 4 10 10 10
7 4 10
1 2 3 -842150451 -842150451 -842150451 -842150451 -842150451 -842150451 -842150451
-------------------------------------------
10 9 8 7 6 5 10 10 10 10
7 5 10
1 2 3 4 -842150451 -842150451 -842150451 -842150451 -842150451 -842150451
-------------------------------------------
10 9 8 7 6 10 10 10 10 10
7 6 10
1 2 3 4 5 -842150451 -842150451 -842150451 -842150451 -842150451
-------------------------------------------
10 9 8 7 10 10 10 10 10 10
7 10 10
1 2 3 4 5 6 -842150451 -842150451 -842150451 -842150451
-------------------------------------------
10 9 8 10 10 10 10 10 10 10
8 10 10
1 2 3 4 5 6 7 -842150451 -842150451 -842150451
-------------------------------------------
10 9 10 10 10 10 10 10 10 10
9 10 10
1 2 3 4 5 6 7 8 -842150451 -842150451
-------------------------------------------
10 10 10 10 10 10 10 10 10 10
10 10 10
1 2 3 4 5 6 7 8 9 -842150451
-------------------------------------------
10 10 10 10 10 10 10 10 10 10
10 10 10
1 2 3 4 5 6 7 8 9 10
-------------------------------------------
Количество сравнений: 62
Количество перемещений: 78
Результат работы сортировки:
        1 2 3 4 5 6 7 8 9 10
*/
/*
Test (для сравнительной хар-ки):

n  = 10

Исходный массив в лучшем случае:
        1 2 3 4 5 6 7 8 9 10
Количество сравнений: 64
Количество перемещений: 77
Результат работы сортировки:
        1 2 3 4 5 6 7 8 9 10

-----------------------------------------------

Исходный массив в худшем случае:
        10 9 8 7 6 5 4 3 2 1
Количество сравнений: 62
Количество перемещений: 78
Результат работы сортировки:
        1 2 3 4 5 6 7 8 9 10

-----------------------------------------------

Исходный массив в среднем случае:
        -1 0 -5 -1 5 -8 7 3 8 5
Количество сравнений: 64
Количество перемещений: 75
Результат работы сортировки:
        -8 -5 -1 -1 0 3 5 5 7 8
*/
